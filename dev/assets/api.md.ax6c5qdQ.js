import{_ as e,c as r,o as a,a7 as t}from"./chunks/framework.CAime7m4.js";const f=JSON.parse('{"title":"","description":"","frontmatter":{"outline":"deep"},"headers":[],"relativePath":"api.md","filePath":"api.md","lastUpdated":null}'),o={name:"api.md"},i=t('<h2 id="Public-API" tabindex="-1">Public API <a class="header-anchor" href="#Public-API" aria-label="Permalink to &quot;Public API {#Public-API}&quot;">​</a></h2><h2 id="Internal-API" tabindex="-1">Internal API <a class="header-anchor" href="#Internal-API" aria-label="Permalink to &quot;Internal API {#Internal-API}&quot;">​</a></h2><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="LinearAlgebra.I-Tuple{Trace.Scene}" href="#LinearAlgebra.I-Tuple{Trace.Scene}">#</a> <b><u>LinearAlgebra.I</u></b> — <i>Method</i>. <p>Render scene.</p><p><a href="https://github.com/pxl-th/Trace.jl/blob/a44acbc81676a3dbec3dd81c7fbd8c6b03a935f9/src/integrators/sampler.jl#L9-L11" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Trace.MAX_BxDF" href="#Trace.MAX_BxDF">#</a> <b><u>Trace.MAX_BxDF</u></b> — <i>Constant</i>. <p>Maximum allowed number of BxDF components in BSDF.</p><p><a href="https://github.com/pxl-th/Trace.jl/blob/a44acbc81676a3dbec3dd81c7fbd8c6b03a935f9/src/materials/bsdf.jl#L1-L3" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Trace.PRIMES" href="#Trace.PRIMES">#</a> <b><u>Trace.PRIMES</u></b> — <i>Constant</i>. <p>First 1023 prime numbers (omitting 2). Used in <code>radical_inverse</code> function.</p><p><a href="https://github.com/pxl-th/Trace.jl/blob/a44acbc81676a3dbec3dd81c7fbd8c6b03a935f9/src/sampler/primes.jl#L1-L4" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Trace.BSDF" href="#Trace.BSDF">#</a> <b><u>Trace.BSDF</u></b> — <i>Type</i>. <p>Evaluate BSDF function given incident and outgoind directions.</p><p><a href="https://github.com/pxl-th/Trace.jl/blob/a44acbc81676a3dbec3dd81c7fbd8c6b03a935f9/src/materials/bsdf.jl#L76-L78" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Trace.DirectionalLight" href="#Trace.DirectionalLight">#</a> <b><u>Trace.DirectionalLight</u></b> — <i>Type</i>. <p>Directional light does not take medium interface, since only reasonable interface for it is vacuum, otherwise all the light would&#39;ve been absorbed by the medium, since the light is infinitely far away.</p><p><a href="https://github.com/pxl-th/Trace.jl/blob/a44acbc81676a3dbec3dd81c7fbd8c6b03a935f9/src/lights/directional.jl#L1-L5" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Trace.FilmTile-Tuple{Trace.Film, Trace.Bounds2}" href="#Trace.FilmTile-Tuple{Trace.Film, Trace.Bounds2}">#</a> <b><u>Trace.FilmTile</u></b> — <i>Method</i>. <p>Bounds should start from 1 not 0.</p><p><a href="https://github.com/pxl-th/Trace.jl/blob/a44acbc81676a3dbec3dd81c7fbd8c6b03a935f9/src/film.jl#L117-L119" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Trace.LambertianReflection" href="#Trace.LambertianReflection">#</a> <b><u>Trace.LambertianReflection</u></b> — <i>Type</i>. <p>Lambertian Reflection models a perfect diffuse surface that scatters incident illumination equally in all directions.</p><p><a href="https://github.com/pxl-th/Trace.jl/blob/a44acbc81676a3dbec3dd81c7fbd8c6b03a935f9/src/reflection/lambertian.jl#L1-L4" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Trace.LambertianReflection-Union{Tuple{GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}}, Tuple{S}} where S&lt;:Trace.Spectrum" href="#Trace.LambertianReflection-Union{Tuple{GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}}, Tuple{S}} where S&lt;:Trace.Spectrum">#</a> <b><u>Trace.LambertianReflection</u></b> — <i>Method</i>. <p>Reflection distribution is constant and divides reflectance spectrum equally over the hemisphere.</p><p><a href="https://github.com/pxl-th/Trace.jl/blob/a44acbc81676a3dbec3dd81c7fbd8c6b03a935f9/src/reflection/lambertian.jl#L18-L21" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Trace.LambertianTransmission" href="#Trace.LambertianTransmission">#</a> <b><u>Trace.LambertianTransmission</u></b> — <i>Type</i>. <p>Lambertian Transmission models perfect transmission.</p><p><a href="https://github.com/pxl-th/Trace.jl/blob/a44acbc81676a3dbec3dd81c7fbd8c6b03a935f9/src/reflection/lambertian.jl#L45-L47" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Trace.MatteMaterial-Union{Tuple{T}, Tuple{Trace.SurfaceInteraction, Bool, Type{T}}} where T&lt;:Union{Val{:Radiance}, Val{:Importance}}" href="#Trace.MatteMaterial-Union{Tuple{T}, Tuple{Trace.SurfaceInteraction, Bool, Type{T}}} where T&lt;:Union{Val{:Radiance}, Val{:Importance}}">#</a> <b><u>Trace.MatteMaterial</u></b> — <i>Method</i>. <p>Compute scattering function.</p><p><a href="https://github.com/pxl-th/Trace.jl/blob/a44acbc81676a3dbec3dd81c7fbd8c6b03a935f9/src/materials/material.jl#L13-L15" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Trace.MixTexture" href="#Trace.MixTexture">#</a> <b><u>Trace.MixTexture</u></b> — <i>Type</i>. <p><code>texture_1</code> &amp; <code>texture_2</code> may be of any single texture type, but <code>mix</code> should be a texture that returns floating-point value that is used to interpolate between the first two.</p><p><a href="https://github.com/pxl-th/Trace.jl/blob/a44acbc81676a3dbec3dd81c7fbd8c6b03a935f9/src/textures/basic.jl#L21-L25" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Trace.OrenNayar" href="#Trace.OrenNayar">#</a> <b><u>Trace.OrenNayar</u></b> — <i>Type</i>. <p>Describes rough surfaces by V-shaped microfacets described by a spherical Gaussian distribution with parameter <code>σ</code> –- the standard deviation of the microfacet angle.</p><p><a href="https://github.com/pxl-th/Trace.jl/blob/a44acbc81676a3dbec3dd81c7fbd8c6b03a935f9/src/reflection/microfacet.jl#L1-L5" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Trace.SpecularReflection-Union{Tuple{GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}}, Tuple{F}, Tuple{S}} where {S&lt;:Trace.Spectrum, F&lt;:Trace.Fresnel}" href="#Trace.SpecularReflection-Union{Tuple{GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}}, Tuple{F}, Tuple{S}} where {S&lt;:Trace.Spectrum, F&lt;:Trace.Fresnel}">#</a> <b><u>Trace.SpecularReflection</u></b> — <i>Method</i>. <p>Return value of the distribution function for the given pair of directions. For specular reflection, no scattering is returned, since for arbitrary directions δ-funcion returns no scattering.</p><p><a href="https://github.com/pxl-th/Trace.jl/blob/a44acbc81676a3dbec3dd81c7fbd8c6b03a935f9/src/reflection/specular.jl#L18-L22" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Trace.SpecularTransmission-Union{Tuple{GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}}, Tuple{T}, Tuple{S}} where {S&lt;:Trace.Spectrum, T&lt;:Union{Val{:Radiance}, Val{:Importance}}}" href="#Trace.SpecularTransmission-Union{Tuple{GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}}, Tuple{T}, Tuple{S}} where {S&lt;:Trace.Spectrum, T&lt;:Union{Val{:Radiance}, Val{:Importance}}}">#</a> <b><u>Trace.SpecularTransmission</u></b> — <i>Method</i>. <p>Return value of the distribution function for the given pair of directions. For specular transmission, no scattering is returned, since for arbitrary directions δ-funcion returns no scattering.</p><p><a href="https://github.com/pxl-th/Trace.jl/blob/a44acbc81676a3dbec3dd81c7fbd8c6b03a935f9/src/reflection/specular.jl#L68-L72" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Trace.TransformMapping3D" href="#Trace.TransformMapping3D">#</a> <b><u>Trace.TransformMapping3D</u></b> — <i>Type</i>. <p>3D mapping that takes world space coordinate of the point and applies a linear transformation to it. This will often be a transformation that takes the point back to the primitive&#39;s object space.</p><p>Because a linear mapping is used, the differential change in texture coordinates can be found by applying the same transformation to the partial derivatives of the position.</p><p><a href="https://github.com/pxl-th/Trace.jl/blob/a44acbc81676a3dbec3dd81c7fbd8c6b03a935f9/src/textures/mapping.jl#L40-L48" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Trace.TrowbridgeReitzDistribution" href="#Trace.TrowbridgeReitzDistribution">#</a> <b><u>Trace.TrowbridgeReitzDistribution</u></b> — <i>Type</i>. <p>Microfacet distribution function based on Gaussian distribution of microfacet slopes. Distribution has higher tails, it falls off to zero more slowly for directions far from the surface normal.</p><p><a href="https://github.com/pxl-th/Trace.jl/blob/a44acbc81676a3dbec3dd81c7fbd8c6b03a935f9/src/reflection/microfacet.jl#L47-L52" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Trace.UVMapping2D" href="#Trace.UVMapping2D">#</a> <b><u>Trace.UVMapping2D</u></b> — <i>Type</i>. <p>Simplest mapping uses <code>(u, v)</code> coordinates from the <code>SurfaceInteraction</code> to compute texture coordinates and can be offset and scaled with user-supplied values in each dimension.</p><p><a href="https://github.com/pxl-th/Trace.jl/blob/a44acbc81676a3dbec3dd81c7fbd8c6b03a935f9/src/textures/mapping.jl#L4-L8" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Trace.D-Tuple{Trace.TrowbridgeReitzDistribution, GeometryBasics.Vec{3, Float32}}" href="#Trace.D-Tuple{Trace.TrowbridgeReitzDistribution, GeometryBasics.Vec{3, Float32}}">#</a> <b><u>Trace.D</u></b> — <i>Method</i>. <p>Distribution function, which gives the differential area of microfacets with the surface normal <code>w</code>.</p><p><a href="https://github.com/pxl-th/Trace.jl/blob/a44acbc81676a3dbec3dd81c7fbd8c6b03a935f9/src/reflection/microfacet.jl#L94-L97" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Trace.add_sample!-Union{Tuple{S}, Tuple{Trace.FilmTile, GeometryBasics.Point{2, Float32}, S}, Tuple{Trace.FilmTile, GeometryBasics.Point{2, Float32}, S, Float32}} where S&lt;:Trace.Spectrum" href="#Trace.add_sample!-Union{Tuple{S}, Tuple{Trace.FilmTile, GeometryBasics.Point{2, Float32}, S}, Tuple{Trace.FilmTile, GeometryBasics.Point{2, Float32}, S, Float32}} where S&lt;:Trace.Spectrum">#</a> <b><u>Trace.add_sample!</u></b> — <i>Method</i>. <p>Add sample contribution to the film tile.</p><ul><li><code>point::Point2f</code>: should start from 1 not 0. And is relative to the film, not the film tile.</li></ul><p><a href="https://github.com/pxl-th/Trace.jl/blob/a44acbc81676a3dbec3dd81c7fbd8c6b03a935f9/src/film.jl#L127-L133" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Trace.blackbody!-Tuple{Vector{Float32}, Vector{Float32}, Float32}" href="#Trace.blackbody!-Tuple{Vector{Float32}, Vector{Float32}, Float32}">#</a> <b><u>Trace.blackbody!</u></b> — <i>Method</i>. <p>Compute emitted radiance by blackbody at the given temperature for the wavelengths.</p><p><strong>Args</strong></p><ul><li><p><code>Le::Vector{Float32}</code>: Preallocated output vector for computed radiance.</p></li><li><p><code>λ::Vector{Float32}</code>: Wavelengths for which to compute radiance. Their values should be in <code>nm</code>.</p></li><li><p><code>T::Float32</code>: Temperature in Kelvin at which to compute radiance.</p></li></ul><p><a href="https://github.com/pxl-th/Trace.jl/blob/a44acbc81676a3dbec3dd81c7fbd8c6b03a935f9/src/lights/emission.jl#L1-L11" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Trace.blackbody-Tuple{Vector{Float32}, Float32}" href="#Trace.blackbody-Tuple{Vector{Float32}, Float32}">#</a> <b><u>Trace.blackbody</u></b> — <i>Method</i>. <p>Allocating version of <code>blackbody!</code> function.</p><p><a href="https://github.com/pxl-th/Trace.jl/blob/a44acbc81676a3dbec3dd81c7fbd8c6b03a935f9/src/lights/emission.jl#L22-L24" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Trace.blackbody_normalized!-Tuple{Vector{Float32}, Vector{Float32}, Float32}" href="#Trace.blackbody_normalized!-Tuple{Vector{Float32}, Vector{Float32}, Float32}">#</a> <b><u>Trace.blackbody_normalized!</u></b> — <i>Method</i>. <p>Compute normalized SPD for a blackbody, with maximum value of the SPD at any wavelength is 1.</p><p><strong>Args</strong></p><ul><li><p><code>Le::Vector{Float32}</code>: Preallocated output vector for computed radiance.</p></li><li><p><code>λ::Vector{Float32}</code>: Wavelengths for which to compute radiance. Their values should be in <code>nm</code>.</p></li><li><p><code>T::Float32</code>: Temperature in Kelvin at which to compute radiance.</p></li></ul><p><a href="https://github.com/pxl-th/Trace.jl/blob/a44acbc81676a3dbec3dd81c7fbd8c6b03a935f9/src/lights/emission.jl#L31-L41" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Trace.compute_differentials!-Tuple{Trace.SurfaceInteraction, Trace.RayDifferentials}" href="#Trace.compute_differentials!-Tuple{Trace.SurfaceInteraction, Trace.RayDifferentials}">#</a> <b><u>Trace.compute_differentials!</u></b> — <i>Method</i>. <p>Compute partial derivatives needed for computing sampling rates for things like texture antialiasing.</p><p><a href="https://github.com/pxl-th/Trace.jl/blob/a44acbc81676a3dbec3dd81c7fbd8c6b03a935f9/src/surface_interaction.jl#L92-L95" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Trace.compute_pdf-Union{Tuple{B}, Tuple{B, GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}}} where B&lt;:Trace.BxDF" href="#Trace.compute_pdf-Union{Tuple{B}, Tuple{B, GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}}} where B&lt;:Trace.BxDF">#</a> <b><u>Trace.compute_pdf</u></b> — <i>Method</i>. <p>Compute PDF value for the given directions. In comparison, <code>sample_f</code> computes PDF value for the incident directions <em>it</em> chooses given the outgoing direction, while this returns a value of PDF for the given pair of directions.</p><p><a href="https://github.com/pxl-th/Trace.jl/blob/a44acbc81676a3dbec3dd81c7fbd8c6b03a935f9/src/reflection/bxdf.jl#L17-L22" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Trace.compute_scattering!-Union{Tuple{T}, Tuple{Trace.SurfaceInteraction, Trace.RayDifferentials}, Tuple{Trace.SurfaceInteraction, Trace.RayDifferentials, Bool}, Tuple{Trace.SurfaceInteraction, Trace.RayDifferentials, Bool, Type{T}}} where T&lt;:Union{Val{:Radiance}, Val{:Importance}}" href="#Trace.compute_scattering!-Union{Tuple{T}, Tuple{Trace.SurfaceInteraction, Trace.RayDifferentials}, Tuple{Trace.SurfaceInteraction, Trace.RayDifferentials, Bool}, Tuple{Trace.SurfaceInteraction, Trace.RayDifferentials, Bool, Type{T}}} where T&lt;:Union{Val{:Radiance}, Val{:Importance}}">#</a> <b><u>Trace.compute_scattering!</u></b> — <i>Method</i>. <p>If an intersection was found, it is necessary to determine, how the surface&#39;s material scatters light. <code>compute_scattering!</code> method evaluates texture functions to determine surface properties and then initializing a representation of the BSDF at the point.</p><p><a href="https://github.com/pxl-th/Trace.jl/blob/a44acbc81676a3dbec3dd81c7fbd8c6b03a935f9/src/surface_interaction.jl#L134-L140" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Trace.cos_θ-Tuple{GeometryBasics.Vec{3, Float32}}" href="#Trace.cos_θ-Tuple{GeometryBasics.Vec{3, Float32}}">#</a> <b><u>Trace.cos_θ</u></b> — <i>Method</i>. <p>The shading coordinate system gives a frame for expressing directions in spherical coordinates (θ, ϕ). The angle θ is measured from the given direction to the z-axis and ϕ is the angle formed with the x-axis after projection of the direction onto xy-plane.</p><p>Since normal is <code>(0, 0, 1) → cos_θ = n · w = (0, 0, 1) ⋅ w = w.z</code>.</p><p><a href="https://github.com/pxl-th/Trace.jl/blob/a44acbc81676a3dbec3dd81c7fbd8c6b03a935f9/src/Trace.jl#L92-L100" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Trace.face_forward-Tuple{Any, Any}" href="#Trace.face_forward-Tuple{Any, Any}">#</a> <b><u>Trace.face_forward</u></b> — <i>Method</i>. <p>Flip normal <code>n</code> so that it lies in the same hemisphere as <code>v</code>.</p><p><a href="https://github.com/pxl-th/Trace.jl/blob/a44acbc81676a3dbec3dd81c7fbd8c6b03a935f9/src/Trace.jl#L157-L159" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Trace.fresnel_conductor-Union{Tuple{S}, Tuple{Float32, S, S, S}} where S&lt;:Trace.Spectrum" href="#Trace.fresnel_conductor-Union{Tuple{S}, Tuple{Float32, S, S, S}} where S&lt;:Trace.Spectrum">#</a> <b><u>Trace.fresnel_conductor</u></b> — <i>Method</i>. <p>General Fresnel reflection formula with complex index of refraction η^ = η + ik, where some incident light is potentially absorbed by the material and turned into heat. k - is referred to as the absorption coefficient.</p><p><a href="https://github.com/pxl-th/Trace.jl/blob/a44acbc81676a3dbec3dd81c7fbd8c6b03a935f9/src/reflection/bxdf.jl#L97-L101" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Trace.fresnel_dielectric-Tuple{Float32, Float32, Float32}" href="#Trace.fresnel_dielectric-Tuple{Float32, Float32, Float32}">#</a> <b><u>Trace.fresnel_dielectric</u></b> — <i>Method</i>. <p>Compute Fresnel reflection formula for dielectric materials and unpolarized light. Which describes the amount of light reflected from a surface.</p><ul><li><p><code>cos_θi::Float32</code>: Cosine of the incident angle w.r.t. normal.</p></li><li><p><code>ηi::Float32</code>: index of refraction for the incident media.</p></li><li><p><code>ηt::Float32</code>: index of refraction for the transmitted media.</p></li></ul><p><a href="https://github.com/pxl-th/Trace.jl/blob/a44acbc81676a3dbec3dd81c7fbd8c6b03a935f9/src/reflection/bxdf.jl#L65-L73" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Trace.generate_ray-Union{Tuple{C}, Tuple{C, Trace.CameraSample}} where C&lt;:Trace.Camera" href="#Trace.generate_ray-Union{Tuple{C}, Tuple{C, Trace.CameraSample}} where C&lt;:Trace.Camera">#</a> <b><u>Trace.generate_ray</u></b> — <i>Method</i>. <p>Compute the ray corresponding to a given sample. It is IMPORTANT that the direction vector of ray is normalized. Other parts of the system assume it to be so.</p><p>Returns generated ray &amp; floating point that affects how much the radiance, arriving at the film plane along generated ray, contributes to the final image. Simple camera models can return 1, but cameras with simulated physical lenses set this value to indicate how much light carries through the lenses, based on their optical properties.</p><p><a href="https://github.com/pxl-th/Trace.jl/blob/a44acbc81676a3dbec3dd81c7fbd8c6b03a935f9/src/camera/camera.jl#L28-L38" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Trace.generate_ray_differential-Union{Tuple{C}, Tuple{C, Trace.CameraSample}} where C&lt;:Trace.Camera" href="#Trace.generate_ray_differential-Union{Tuple{C}, Tuple{C, Trace.CameraSample}} where C&lt;:Trace.Camera">#</a> <b><u>Trace.generate_ray_differential</u></b> — <i>Method</i>. <p>Same as <code>generate_ray</code>, but also computes rays for pixels shifted one pixel in x &amp; y directions on the film plane. Useful for anti-aliasing textures.</p><p><a href="https://github.com/pxl-th/Trace.jl/blob/a44acbc81676a3dbec3dd81c7fbd8c6b03a935f9/src/camera/camera.jl#L43-L47" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Trace.get_physical_extension-Tuple{Trace.Film}" href="#Trace.get_physical_extension-Tuple{Trace.Film}">#</a> <b><u>Trace.get_physical_extension</u></b> — <i>Method</i>. <p>Extent of the film in the scene. This is needed for realistic cameras.</p><p><a href="https://github.com/pxl-th/Trace.jl/blob/a44acbc81676a3dbec3dd81c7fbd8c6b03a935f9/src/film.jl#L75-L78" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Trace.get_pixel-Tuple{Trace.Film, GeometryBasics.Point{2, Float32}}" href="#Trace.get_pixel-Tuple{Trace.Film, GeometryBasics.Point{2, Float32}}">#</a> <b><u>Trace.get_pixel</u></b> — <i>Method</i>. <p>Point in (x, y) format.</p><p><a href="https://github.com/pxl-th/Trace.jl/blob/a44acbc81676a3dbec3dd81c7fbd8c6b03a935f9/src/film.jl#L174-L176" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Trace.get_pixel-Tuple{Trace.FilmTile, GeometryBasics.Point{2, Float32}}" href="#Trace.get_pixel-Tuple{Trace.FilmTile, GeometryBasics.Point{2, Float32}}">#</a> <b><u>Trace.get_pixel</u></b> — <i>Method</i>. <p>Point in (x, y) format.</p><p><a href="https://github.com/pxl-th/Trace.jl/blob/a44acbc81676a3dbec3dd81c7fbd8c6b03a935f9/src/film.jl#L166-L168" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Trace.get_sample_bounds-Tuple{Trace.Film}" href="#Trace.get_sample_bounds-Tuple{Trace.Film}">#</a> <b><u>Trace.get_sample_bounds</u></b> — <i>Method</i>. <p>Range of integer pixels that the <code>Sampler</code> is responsible for generating samples for.</p><p><a href="https://github.com/pxl-th/Trace.jl/blob/a44acbc81676a3dbec3dd81c7fbd8c6b03a935f9/src/film.jl#L64-L67" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Trace.intersect_p-Tuple{Trace.Bounds3, Trace.AbstractRay, GeometryBasics.Vec{3, Float32}, GeometryBasics.Point3{UInt8}}" href="#Trace.intersect_p-Tuple{Trace.Bounds3, Trace.AbstractRay, GeometryBasics.Vec{3, Float32}, GeometryBasics.Point3{UInt8}}">#</a> <b><u>Trace.intersect_p</u></b> — <i>Method</i>. <p>dir_is_negative: 1 – false, 2 – true</p><p><a href="https://github.com/pxl-th/Trace.jl/blob/a44acbc81676a3dbec3dd81c7fbd8c6b03a935f9/src/bounds.jl#L177-L179" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Trace.le-Tuple{Trace.Light, Union{Trace.Ray, Trace.RayDifferentials}}" href="#Trace.le-Tuple{Trace.Light, Union{Trace.Ray, Trace.RayDifferentials}}">#</a> <b><u>Trace.le</u></b> — <i>Method</i>. <p>Emmited light if ray hit an area light source. By default light sources have no area.</p><p><a href="https://github.com/pxl-th/Trace.jl/blob/a44acbc81676a3dbec3dd81c7fbd8c6b03a935f9/src/lights/light.jl#L37-L40" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Trace.map-Tuple{Trace.UVMapping2D, Trace.SurfaceInteraction}" href="#Trace.map-Tuple{Trace.UVMapping2D, Trace.SurfaceInteraction}">#</a> <b><u>Trace.map</u></b> — <i>Method</i>. <p>Given surface interaction <code>si</code> at the shading point, return <code>(s, t)</code> texture coordinates and estimated changes in <code>(s, t)</code> w.r.t. pixel <code>x</code> &amp; <code>y</code> coordinates.</p><p><strong>Paramters:</strong></p><ul><li><p><code>m::UVMapping2D</code>: UVMapping with offset &amp; scale parameters.</p></li><li><p><code>si::SurfaceInteraction</code>: SurfaceInteraction at the shading point.</p></li></ul><p><strong>Returns:</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>`Tuple{Point2f, Vec2f, Vec2f}`:</span></span>\n<span class="line"><span>    Texture coordinates at the shading point, estimated changes</span></span>\n<span class="line"><span>    in `(s, t)` w.r.t. pixel `x` &amp; `y` coordinates.</span></span></code></pre></div><p><a href="https://github.com/pxl-th/Trace.jl/blob/a44acbc81676a3dbec3dd81c7fbd8c6b03a935f9/src/textures/mapping.jl#L16-L31" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Trace.maximum_extent-Tuple{Trace.Bounds3}" href="#Trace.maximum_extent-Tuple{Trace.Bounds3}">#</a> <b><u>Trace.maximum_extent</u></b> — <i>Method</i>. <p>Return index of the longest axis. Useful for deciding which axis to subdivide, when building ray-tracing acceleration structures.</p><p>1 - x, 2 - y, 3 - z.</p><p><a href="https://github.com/pxl-th/Trace.jl/blob/a44acbc81676a3dbec3dd81c7fbd8c6b03a935f9/src/bounds.jl#L105-L111" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Trace.offset-Tuple{Trace.Bounds3, GeometryBasics.Point{3, Float32}}" href="#Trace.offset-Tuple{Trace.Bounds3, GeometryBasics.Point{3, Float32}}">#</a> <b><u>Trace.offset</u></b> — <i>Method</i>. <p>Get offset of a point from the minimum point of the bounds.</p><p><a href="https://github.com/pxl-th/Trace.jl/blob/a44acbc81676a3dbec3dd81c7fbd8c6b03a935f9/src/bounds.jl#L133" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Trace.power-Tuple{Trace.PointLight}" href="#Trace.power-Tuple{Trace.PointLight}">#</a> <b><u>Trace.power</u></b> — <i>Method</i>. <p>Total power emitted by the light source over the entire sphere of directions.</p><p><a href="https://github.com/pxl-th/Trace.jl/blob/a44acbc81676a3dbec3dd81c7fbd8c6b03a935f9/src/lights/point.jl#L71-L73" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Trace.power-Union{Tuple{Trace.DirectionalLight{S}}, Tuple{S}} where S&lt;:Trace.Spectrum" href="#Trace.power-Union{Tuple{Trace.DirectionalLight{S}}, Tuple{S}} where S&lt;:Trace.Spectrum">#</a> <b><u>Trace.power</u></b> — <i>Method</i>. <p>The total power emitted by the directional light is related to the spatial extent of the scene and equals the amount of power arriving at the inscribed by bounding sphere disk: <code>I * π * r^2</code>.</p><p><a href="https://github.com/pxl-th/Trace.jl/blob/a44acbc81676a3dbec3dd81c7fbd8c6b03a935f9/src/lights/directional.jl#L49-L53" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Trace.reflect-Tuple{GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}}" href="#Trace.reflect-Tuple{GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}}">#</a> <b><u>Trace.reflect</u></b> — <i>Method</i>. <p>Reflect <code>wo</code> about <code>n</code>.</p><p><a href="https://github.com/pxl-th/Trace.jl/blob/a44acbc81676a3dbec3dd81c7fbd8c6b03a935f9/src/Trace.jl#L115-L117" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Trace.refract-Tuple{GeometryBasics.Vec{3, Float32}, Trace.Normal3f, Float32}" href="#Trace.refract-Tuple{GeometryBasics.Vec{3, Float32}, Trace.Normal3f, Float32}">#</a> <b><u>Trace.refract</u></b> — <i>Method</i>. <p>Compute refracted direction <code>wt</code> given an incident direction <code>wi</code>, surface normal <code>n</code> in the same hemisphere as <code>wi</code> and <code>η</code>, the ratio of indices of refraction in the incident transmitted media respectively.</p><p>Returned boolean indicates whether a valid refracted ray was returned or is it the case of total internal reflection.</p><p><a href="https://github.com/pxl-th/Trace.jl/blob/a44acbc81676a3dbec3dd81c7fbd8c6b03a935f9/src/reflection/bxdf.jl#L44-L51" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Trace.roughness_to_α-Tuple{Float32}" href="#Trace.roughness_to_α-Tuple{Float32}">#</a> <b><u>Trace.roughness_to_α</u></b> — <i>Method</i>. <p>Map [0, 1] scalar to BRDF&#39;s roughness, where values close to zero correspond to near-perfect specular reflection, rather than by specifying α values directly.</p><p><a href="https://github.com/pxl-th/Trace.jl/blob/a44acbc81676a3dbec3dd81c7fbd8c6b03a935f9/src/reflection/microfacet.jl#L74-L78" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Trace.sample_f-Tuple{Trace.BSDF, GeometryBasics.Vec{3, Float32}, GeometryBasics.Point{2, Float32}, UInt8}" href="#Trace.sample_f-Tuple{Trace.BSDF, GeometryBasics.Vec{3, Float32}, GeometryBasics.Point{2, Float32}, UInt8}">#</a> <b><u>Trace.sample_f</u></b> — <i>Method</i>. <p>Compute incident ray direction for a given outgoing direction and a given mode of light scattering corresponding to perfect specular reflection or refraction.</p><p><a href="https://github.com/pxl-th/Trace.jl/blob/a44acbc81676a3dbec3dd81c7fbd8c6b03a935f9/src/materials/bsdf.jl#L102-L106" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Trace.sample_f-Union{Tuple{B}, Tuple{B, GeometryBasics.Vec{3, Float32}, GeometryBasics.Point{2, Float32}}} where B&lt;:Trace.BxDF" href="#Trace.sample_f-Union{Tuple{B}, Tuple{B, GeometryBasics.Vec{3, Float32}, GeometryBasics.Point{2, Float32}}} where B&lt;:Trace.BxDF">#</a> <b><u>Trace.sample_f</u></b> — <i>Method</i>. <p>Compute the direction of incident light wi, given an outgoing direction wo and return the value of BxDF for the pair of directions.</p><p><strong>Note</strong> all BxDFs that implement this method, have to implement <code>compute_pdf</code> as well.</p><p><a href="https://github.com/pxl-th/Trace.jl/blob/a44acbc81676a3dbec3dd81c7fbd8c6b03a935f9/src/reflection/bxdf.jl#L27-L33" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Trace.sample_f-Union{Tuple{F}, Tuple{S}, Tuple{Trace.SpecularReflection{S, F}, GeometryBasics.Vec{3, Float32}, GeometryBasics.Point{2, Float32}}} where {S&lt;:Trace.Spectrum, F&lt;:Trace.Fresnel}" href="#Trace.sample_f-Union{Tuple{F}, Tuple{S}, Tuple{Trace.SpecularReflection{S, F}, GeometryBasics.Vec{3, Float32}, GeometryBasics.Point{2, Float32}}} where {S&lt;:Trace.Spectrum, F&lt;:Trace.Fresnel}">#</a> <b><u>Trace.sample_f</u></b> — <i>Method</i>. <p>Compute the direction of incident light wi, given an outgoing direction wo and return the value of BxDF for the pair of directions. <code>sample</code> parameter isn&#39;t needed for the δ-distribution.</p><p><a href="https://github.com/pxl-th/Trace.jl/blob/a44acbc81676a3dbec3dd81c7fbd8c6b03a935f9/src/reflection/specular.jl#L29-L33" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Trace.sample_f-Union{Tuple{T}, Tuple{S}, Tuple{Trace.FresnelSpecular{S, T}, GeometryBasics.Vec{3, Float32}, GeometryBasics.Point{2, Float32}}} where {S&lt;:Trace.Spectrum, T&lt;:Union{Val{:Radiance}, Val{:Importance}}}" href="#Trace.sample_f-Union{Tuple{T}, Tuple{S}, Tuple{Trace.FresnelSpecular{S, T}, GeometryBasics.Vec{3, Float32}, GeometryBasics.Point{2, Float32}}} where {S&lt;:Trace.Spectrum, T&lt;:Union{Val{:Radiance}, Val{:Importance}}}">#</a> <b><u>Trace.sample_f</u></b> — <i>Method</i>. <p>Compute the direction of incident light wi, given an outgoing direction wo and return the value of BxDF for the pair of directions.</p><p><a href="https://github.com/pxl-th/Trace.jl/blob/a44acbc81676a3dbec3dd81c7fbd8c6b03a935f9/src/reflection/specular.jl#L141-L144" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Trace.sample_f-Union{Tuple{T}, Tuple{S}, Tuple{Trace.SpecularTransmission{S, T}, GeometryBasics.Vec{3, Float32}, GeometryBasics.Point{2, Float32}}} where {S&lt;:Trace.Spectrum, T&lt;:Union{Val{:Radiance}, Val{:Importance}}}" href="#Trace.sample_f-Union{Tuple{T}, Tuple{S}, Tuple{Trace.SpecularTransmission{S, T}, GeometryBasics.Vec{3, Float32}, GeometryBasics.Point{2, Float32}}} where {S&lt;:Trace.Spectrum, T&lt;:Union{Val{:Radiance}, Val{:Importance}}}">#</a> <b><u>Trace.sample_f</u></b> — <i>Method</i>. <p>Compute the direction of incident light wi, given an outgoing direction wo and return the value of BxDF for the pair of directions. <code>sample</code> parameter isn&#39;t needed for the δ-distribution.</p><p><a href="https://github.com/pxl-th/Trace.jl/blob/a44acbc81676a3dbec3dd81c7fbd8c6b03a935f9/src/reflection/specular.jl#L79-L83" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Trace.sample_li-Tuple{Trace.PointLight, Trace.Interaction, GeometryBasics.Point{2, Float32}}" href="#Trace.sample_li-Tuple{Trace.PointLight, Trace.Interaction, GeometryBasics.Point{2, Float32}}">#</a> <b><u>Trace.sample_li</u></b> — <i>Method</i>. <p>Compute radiance arriving at <code>ref.p</code> interaction point at <code>ref.time</code> time due to that light, assuming there are no occluding objects between them.</p><p><strong>Args</strong></p><ul><li><p><code>p::PointLight</code>: Light which illuminates the interaction point <code>ref</code>.</p></li><li><p><code>ref::Interaction</code>: Interaction point for which to compute radiance.</p></li><li><p><code>u::Point2f</code>: Sampling point that is ignored for <code>PointLight</code>, since it has no area.</p></li></ul><p><strong>Returns</strong></p><p><code>Tuple{S, Vec3f, Float32, VisibilityTester} where S &lt;: Spectrum</code>:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>- `S`: Computed radiance.</span></span>\n<span class="line"><span>- `Vec3f`: Incident direction to the light source `wi`.</span></span>\n<span class="line"><span>- `Float32`: Probability density for the light sample that was taken.</span></span>\n<span class="line"><span>    For `PointLight` it is always `1`.</span></span>\n<span class="line"><span>- `VisibilityTester`: Initialized visibility tester that holds the</span></span>\n<span class="line"><span>    shadow ray that must be traced to verify that</span></span>\n<span class="line"><span>    there are no occluding objects between the light and reference point.</span></span></code></pre></div><p><a href="https://github.com/pxl-th/Trace.jl/blob/a44acbc81676a3dbec3dd81c7fbd8c6b03a935f9/src/lights/point.jl#L27-L49" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Trace.start_pixel-Tuple{Trace.Sampler, GeometryBasics.Point{2, Float32}}" href="#Trace.start_pixel-Tuple{Trace.Sampler, GeometryBasics.Point{2, Float32}}">#</a> <b><u>Trace.start_pixel</u></b> — <i>Method</i>. <p>Other samplers are required to explicitly call this, in their respective implementations.</p><p><a href="https://github.com/pxl-th/Trace.jl/blob/a44acbc81676a3dbec3dd81c7fbd8c6b03a935f9/src/sampler/sampler.jl#L37-L40" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Trace.test_clipping-Tuple{Trace.Sphere, GeometryBasics.Point{3, Float32}, Float32}" href="#Trace.test_clipping-Tuple{Trace.Sphere, GeometryBasics.Point{3, Float32}, Float32}">#</a> <b><u>Trace.test_clipping</u></b> — <i>Method</i>. <p>Test if hit point exceeds clipping parameters of the sphere.</p><p><a href="https://github.com/pxl-th/Trace.jl/blob/a44acbc81676a3dbec3dd81c7fbd8c6b03a935f9/src/shapes/sphere.jl#L62-L64" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Trace.to_grid-Tuple{GeometryBasics.Point{3, Float32}, Trace.Bounds3, GeometryBasics.Point3}" href="#Trace.to_grid-Tuple{GeometryBasics.Point{3, Float32}, Trace.Bounds3, GeometryBasics.Point3}">#</a> <b><u>Trace.to_grid</u></b> — <i>Method</i>. <p>Calculate indices of a point <code>p</code> in grid constrained by <code>bounds</code>.</p><p>Computed indices are in [0, resolution), which is the correct input for <code>hash</code>.</p><p><a href="https://github.com/pxl-th/Trace.jl/blob/a44acbc81676a3dbec3dd81c7fbd8c6b03a935f9/src/integrators/sppm.jl#L472-L476" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Trace.world_to_local-Tuple{Trace.BSDF, GeometryBasics.Vec{3, Float32}}" href="#Trace.world_to_local-Tuple{Trace.BSDF, GeometryBasics.Vec{3, Float32}}">#</a> <b><u>Trace.world_to_local</u></b> — <i>Method</i>. <p>Given the orthonormal vectors s, t, n in world space, the matrix <code>M</code> that transforms vectors in world space to local reflection space is: sx, sy, sz tx, ty, tz nx, ny, nz</p><p>Since it is an orthonormal matrix, its inverse is its transpose.</p><p><a href="https://github.com/pxl-th/Trace.jl/blob/a44acbc81676a3dbec3dd81c7fbd8c6b03a935f9/src/materials/bsdf.jl#L59-L67" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Trace.ρ-Union{Tuple{S}, Tuple{Trace.LambertianReflection{S}, GeometryBasics.Vec{3, Float32}, Int32, Vector{GeometryBasics.Point{2, Float32}}}} where S&lt;:Trace.Spectrum" href="#Trace.ρ-Union{Tuple{S}, Tuple{Trace.LambertianReflection{S}, GeometryBasics.Vec{3, Float32}, Int32, Vector{GeometryBasics.Point{2, Float32}}}} where S&lt;:Trace.Spectrum">#</a> <b><u>Trace.ρ</u></b> — <i>Method</i>. <p>Directional-hemisphirical reflectance value is constant.</p><p><a href="https://github.com/pxl-th/Trace.jl/blob/a44acbc81676a3dbec3dd81c7fbd8c6b03a935f9/src/reflection/lambertian.jl#L26-L28" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Trace.ρ-Union{Tuple{S}, Tuple{Trace.LambertianReflection{S}, Vector{GeometryBasics.Point{2, Float32}}, Vector{GeometryBasics.Point{2, Float32}}}} where S&lt;:Trace.Spectrum" href="#Trace.ρ-Union{Tuple{S}, Tuple{Trace.LambertianReflection{S}, Vector{GeometryBasics.Point{2, Float32}}, Vector{GeometryBasics.Point{2, Float32}}}} where S&lt;:Trace.Spectrum">#</a> <b><u>Trace.ρ</u></b> — <i>Method</i>. <p>Hemispherical-hemisphirical reflectance value is constant.</p><p><a href="https://github.com/pxl-th/Trace.jl/blob/a44acbc81676a3dbec3dd81c7fbd8c6b03a935f9/src/reflection/lambertian.jl#L35-L37" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Trace.∂p-Tuple{Trace.Sphere, GeometryBasics.Point{3, Float32}, Float32, Float32, Float32}" href="#Trace.∂p-Tuple{Trace.Sphere, GeometryBasics.Point{3, Float32}, Float32, Float32, Float32}">#</a> <b><u>Trace.∂p</u></b> — <i>Method</i>. <p>Compute partial derivatives of intersection point in parametric form.</p><p><a href="https://github.com/pxl-th/Trace.jl/blob/a44acbc81676a3dbec3dd81c7fbd8c6b03a935f9/src/shapes/sphere.jl#L85-L87" target="_blank" rel="noreferrer">source</a></p></div><br>',118),c=[i];function l(d,s,n,p,b,u){return a(),r("div",null,c)}const T=e(o,[["render",l]]);export{f as __pageData,T as default};
